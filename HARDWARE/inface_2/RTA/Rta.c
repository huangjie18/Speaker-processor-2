/*********************************************************************
*                                                                    *
*                SEGGER Microcontroller GmbH & Co. KG                *
*        Solutions for real time microcontroller applications        *
*                                                                    *
**********************************************************************
*                                                                    *
* C-file generated by:                                               *
*                                                                    *
*        GUI_Builder for emWin version 5.32                          *
*        Compiled Oct  8 2015, 11:59:02                              *
*        (c) 2015 Segger Microcontroller GmbH & Co. KG               *
*                                                                    *
**********************************************************************
*                                                                    *
*        Internet: www.segger.com  Support: support@segger.com       *
*                                                                    *
**********************************************************************
*/

// USER START (Optionally insert additional includes)
// USER END

#include "DIALOG.h"
#include "data.h"
#include "algorithm.h"

static void huadong(WM_MESSAGE* pMsg);

#define ID_TIMER_SPEC       2  //定义第一个定时器
#define Time_delay			50 //定时器的时间间隔
#define hight_y				70
/*********************************************************************
*
*       Defines
*
**********************************************************************
*/
#define ID_WINDOW_0 (GUI_ID_USER + 0x00)
#define ID_BUTTON_0 (GUI_ID_USER + 0x01)
#define ID_BUTTON_1 (GUI_ID_USER + 0x02)

// USER START (Optionally insert additional defines)
// USER END

/*********************************************************************
*
*       Static data
*
**********************************************************************
*/
static RTA_First_Data * Current_Data;
// USER START (Optionally insert additional static data)
// USER END
extern GUI_CONST_STORAGE GUI_BITMAP bmlannge_yellow;  //橙色logo
/*********************************************************************
*
*       _aDialogCreate
*/
static const GUI_WIDGET_CREATE_INFO _aDialogCreate[] = {
	{ WINDOW_CreateIndirect, "Window", ID_WINDOW_0, 0, 0, 400, 240, 0, 0x0, 0 },

	/*页面切换*/
	{ BUTTON_CreateIndirect, "Button", ID_BUTTON_0, 55, 5, 40, 25, 0, 0x0, 0 },
	{ BUTTON_CreateIndirect, "Button", ID_BUTTON_1, 375 - 70, 5, 40, 25, 0, 0x0, 0 },
	// USER START (Optionally insert additional widgets)
	// USER END
};

/*********************************************************************
*
*       Static code
*
**********************************************************************
*/
/*
*******************************************************************************************
* 函 数 名: Show_Value
* 功能说明: 显示数值
* 形 参: 无
* 返 回 值: 无
*******************************************************************************************
*/
static void Show_Value(void)
{
	char str[10];
	GUI_SetColor(GUI_WHITE); 		//设置颜色
	GUI_SetTextMode(GUI_TM_TRANS);  //设置透明模式
	GUI_SetFont(&GUI_Font24B_1); 	//设置字体
	
	switch(Current_Data->RTA_Channel)
	{
		case RTA_IN1:
			GUI_DispStringHCenterAt("INPUT1_RTA",200,3);
			break;
		
		case RTA_IN2:
			GUI_DispStringHCenterAt("INPUT2_RTA",200,3);
			break;
		
		case RTA_IN3:
			GUI_DispStringHCenterAt("INPUT3_RTA",200,3);
			break;
		
		case RTA_IN4:
			GUI_DispStringHCenterAt("INPUT4_RTA",200,3);
			break;
		
		case RTA_IN5:
			GUI_DispStringHCenterAt("INPUT5_RTA",200,3);
			break;
		
		case RTA_IN6:
			GUI_DispStringHCenterAt("INPUT6_RTA",200,3);
			break;
		
		case RTA_COAL:
			GUI_DispStringHCenterAt("COAX_L_RTA",200,3);
			break;
		
		case RTA_COAR:
			GUI_DispStringHCenterAt("COAX_R_RTA",200,3);
			break;
		
		case RTA_OUT1:
			GUI_DispStringHCenterAt("OUT1_RTA",200,3);
			break;
		
		case RTA_OUT2:
			GUI_DispStringHCenterAt("OUT2_RTA",200,3);
			break;
		
		case RTA_OUT3:
			GUI_DispStringHCenterAt("OUT3_RTA",200,3);
			break;
		
		case RTA_OUT4:
			GUI_DispStringHCenterAt("OUT4_RTA",200,3);
			break;
		
		case RTA_OUT5:
			GUI_DispStringHCenterAt("OUT5_RTA",200,3);
			break;
		
		case RTA_OUT6:
			GUI_DispStringHCenterAt("OUT6_RTA",200,3);
			break;
		
		case RTA_OUT7:
			GUI_DispStringHCenterAt("OUT7_RTA",200,3);
			break;
		
		case RTA_OUT8:
			GUI_DispStringHCenterAt("OUT8_RTA",200,3);
			break;
	}
}

/*
*******************************************************************************************
* 函 数 名: RTA_Choose
* 功能说明: RTA通道选择
* 形 参: 通道
* 返 回 值: 无
*******************************************************************************************
*/
static void RTA_Choose(char channel)
{
	channel = channel;
	
	switch(channel)
	{
		case RTA_IN1:
			RTA_switch(RTA_SWITCH_ADDR,IN1_RTA);//频谱通道选择
			break;
		
		case RTA_IN2:
			RTA_switch(RTA_SWITCH_ADDR,IN2_RTA);//频谱通道选择
			break;
		
		case RTA_IN3:
			RTA_switch(RTA_SWITCH_ADDR,IN3_RTA);//频谱通道选择
			break;
		
		case RTA_IN4:
			RTA_switch(RTA_SWITCH_ADDR,IN4_RTA);//频谱通道选择
			break;
		
		case RTA_IN5:
			RTA_switch(RTA_SWITCH_ADDR,IN5_RTA);//频谱通道选择
			break;
		
		case RTA_IN6:
			RTA_switch(RTA_SWITCH_ADDR,IN6_RTA);//频谱通道选择
			break;
		
		case RTA_COAL:
			RTA_switch(RTA_SWITCH_ADDR,COAX_L_RTA);//频谱通道选择
			break;
		
		case RTA_COAR:
			RTA_switch(RTA_SWITCH_ADDR,COAX_R_RTA);//频谱通道选择
			break;
		
		case RTA_OUT1:
			RTA_switch(RTA_SWITCH_ADDR,OUT1_RTA);//频谱通道选择
			break;
		
		case RTA_OUT2:
			RTA_switch(RTA_SWITCH_ADDR,OUT2_RTA);//频谱通道选择
			break;
		
		case RTA_OUT3:
			RTA_switch(RTA_SWITCH_ADDR,OUT3_RTA);//频谱通道选择
			break;
		
		case RTA_OUT4:
			RTA_switch(RTA_SWITCH_ADDR,OUT4_RTA);//频谱通道选择
			break;
		
		case RTA_OUT5:
			RTA_switch(RTA_SWITCH_ADDR,OUT5_RTA);//频谱通道选择
			break;
		
		case RTA_OUT6:
			RTA_switch(RTA_SWITCH_ADDR,OUT6_RTA);//频谱通道选择
			break;
		
		case RTA_OUT7:
			RTA_switch(RTA_SWITCH_ADDR,OUT7_RTA);//频谱通道选择
			break;
		
		case RTA_OUT8:
			RTA_switch(RTA_SWITCH_ADDR,OUT8_RTA);//频谱通道选择
			break;
	}
}


static const GUI_POINT pPoint_left[] = {
	{ 0, 10 },
	{ 10, 0 },
	{ 10, 20 },
};

static const GUI_POINT pPoint_right[] = {
	{ 10+20, 0 },
	{ 20+20, 10 },
	{ 10+20, 20 },
};

//左边三角形
static void _cbButton_left(WM_MESSAGE * pMsg) //--------------（3）
{
	WM_HWIN hWin;
	hWin = pMsg->hWin;
	switch (pMsg->MsgId)
	{
	case WM_PAINT:
		if (BUTTON_IsPressed(hWin))
		{
			//画红色三角形
			GUI_SetColor(GUI_RED);
			GUI_FillPolygon(pPoint_left, 3, 0, 0);
		}
		else
		{
			//画黑色三角形
			GUI_SetColor(GUI_BLACK);
			GUI_FillPolygon(pPoint_left, 3, 0, 0);
		}

		break;

		//处理默认信息
	default:
		BUTTON_Callback(pMsg);
	}
}

//右边三角形

static void _cbButton_right(WM_MESSAGE * pMsg) //--------------（3）
{
	WM_HWIN hWin;

//	const GUI_PID_STATE* pState = (const GUI_PID_STATE*)pMsg->Data.p;
	hWin = pMsg->hWin;

	switch (pMsg->MsgId)
	{
	case WM_PAINT:
		if (BUTTON_IsPressed(hWin))
		{
			//画红色三角形
			GUI_SetColor(GUI_RED);
			GUI_FillPolygon(pPoint_right, 3, 0, 0);
		}
		else
		{
			//画黑色三角形
			GUI_SetColor(GUI_BLACK);
			GUI_FillPolygon(pPoint_right, 3, 0, 0);
		}

		break;


		//case WM_TOUCH:
		//	if (pMsg->Data.p) {  /* Something happened in our area (pressed or released) */
		//		if (pState->Pressed) {
		//			RMSTC_Value++;
		//			WIDGET_OrState(hWin, BUTTON_STATE_PRESSED);
		//			WM_NotifyParent(hWin, WM_NOTIFICATION_CLICKED);
		//		}
		//		else {
		//			/* React only if button was pressed before ... avoid problems with moving / hiding windows above (such as dropdown) */
		//			
		//		}
		//	}
		//	else {
		//		
		//	}
		//	break;
		//处理默认信息
	default:
		BUTTON_Callback(pMsg);
	}
}

//获得RTA值
double Get_RTA_Value(u8 rta_i)
{
	double db_value_debug;
	rta_i = rta_i;
	switch(rta_i)
	{
		case 0:
			db_value_debug=meter(RTA1_METER_ADDR);//频谱指示
			break;
		
		case 1:
			db_value_debug=meter(RTA2_METER_ADDR);//频谱指示
			break;
		
		case 2:
			db_value_debug=meter(RTA3_METER_ADDR);//频谱指示
			break;
		
		case 3:
			db_value_debug=meter(RTA4_METER_ADDR);//频谱指示
			break;
		
		case 4:
			db_value_debug=meter(RTA5_METER_ADDR);//频谱指示
			break;
		
		case 5:
			db_value_debug=meter(RTA6_METER_ADDR);//频谱指示
			break;
		
		case 6:
			db_value_debug=meter(RTA7_METER_ADDR);//频谱指示
			break;
		
		case 7:
			db_value_debug=meter(RTA8_METER_ADDR);//频谱指示
			break;
		
		case 8:
			db_value_debug=meter(RTA9_METER_ADDR);//频谱指示
			break;
		
		case 9:
			db_value_debug=meter(RTA10_METER_ADDR);//频谱指示
			break;
		
		case 10:
			db_value_debug=meter(RTA11_METER_ADDR);//频谱指示
			break;
		
		case 11:
			db_value_debug=meter(RTA12_METER_ADDR);//频谱指示
			break;
		
		case 12:
			db_value_debug=meter(RTA13_METER_ADDR);//频谱指示
			break;
		
		case 13:
			db_value_debug=meter(RTA14_METER_ADDR);//频谱指示
			break;
		
		case 14:
			db_value_debug=meter(RTA15_METER_ADDR);//频谱指示
			break;
		
		case 15:
			db_value_debug=meter(RTA16_METER_ADDR);//频谱指示
			break;
		
		case 16:
			db_value_debug=meter(RTA17_METER_ADDR);//频谱指示
			break;
		
		case 17:
			db_value_debug=meter(RTA18_METER_ADDR);//频谱指示
			break;
		
		case 18:
			db_value_debug=meter(RTA19_METER_ADDR);//频谱指示
			break;
		
		case 19:
			db_value_debug=meter(RTA20_METER_ADDR);//频谱指示
			break;
		
		case 20:
			db_value_debug=meter(RTA21_METER_ADDR);//频谱指示
			break;
		
		case 21:
			db_value_debug=meter(RTA22_METER_ADDR);//频谱指示
			break;
		
		case 22:
			db_value_debug=meter(RTA23_METER_ADDR);//频谱指示
			break;
		
		case 23:
			db_value_debug=meter(RTA24_METER_ADDR);//频谱指示
			break;
		
		case 24:
			db_value_debug=meter(RTA25_METER_ADDR);//频谱指示
			break;
		
		case 25:
			db_value_debug=meter(RTA26_METER_ADDR);//频谱指示
			break;
		
		case 26:
			db_value_debug=meter(RTA27_METER_ADDR);//频谱指示
			break;
		
		case 27:
			db_value_debug=meter(RTA28_METER_ADDR);//频谱指示
			break;
		
		case 28:
			db_value_debug=meter(RTA29_METER_ADDR);//频谱指示
			break;
		
		case 29:
			db_value_debug=meter(RTA30_METER_ADDR);//频谱指示
			break;
		
		case 30:
			db_value_debug=meter(RTA31_METER_ADDR);//频谱指示
			break;
		
//		case 31:
//			db_value_debug=meter(RTA32_METER_ADDR);//频谱指示
//			break;
	}
	
	return db_value_debug;
}
// USER START (Optionally insert additional static code)
// USER END
static void DisWave(uint16_t x, uint16_t y, uint8_t clr)
{
	static int s_MP3Spec_TopVal[32] = {0};   /* 频谱顶值表 */
	static int s_MP3Spec_CurVal[32] = {0};	  /* 频谱当前值表 */
	static uint8_t  s_MP3Spec_Time[32] = {0};	  /* 顶值停留时间表 */
	const  uint16_t usMaxVal = 230 - hight_y;               /* 高度固定为190个像素 */
	uint16_t i;
	int temp;
	float ufTempValue;  //表示一个高度等于多少值
	


	for (i = 0;i < 31; i++)
	{
		ufTempValue = Get_RTA_Value(i) * 100;
		
		if(ufTempValue < 0 )
		{
			ufTempValue = -ufTempValue;
		}
		else
		{
			ufTempValue = 0;
		}
		
		ufTempValue = ufTempValue/9600;
		
		temp = usMaxVal - (usMaxVal * ufTempValue);
		
		
		/* 2. 更新频谱数值 */
		if(s_MP3Spec_CurVal[i] < temp)
		{
			s_MP3Spec_CurVal[i] = temp;
		}
		else
		{
			if(s_MP3Spec_CurVal[i] > 1)
			{
				s_MP3Spec_CurVal[i] -= 2;
			}
			else
			{
				s_MP3Spec_CurVal[i] = 0;
			}
		}
		
		/* 3. 更新频谱顶值 */
		if(s_MP3Spec_Time[i])
		{
			s_MP3Spec_Time[i]--;
		}
		else 
		{	
			/* 峰值减小1 */
			if(s_MP3Spec_TopVal[i])
			{
				s_MP3Spec_TopVal[i]--;
			}
		}
		
		/* 4. 重设频谱顶值 */
		if(s_MP3Spec_CurVal[i] > s_MP3Spec_TopVal[i])
		{
			s_MP3Spec_TopVal[i] = s_MP3Spec_CurVal[i];
			
			/* 重设峰值停顿时间 */
			s_MP3Spec_Time[i] = 200/Time_delay;
		}
		
		/* 5. 防止超出频谱值和顶值范围，高度固定为128个像素 */
		if(s_MP3Spec_CurVal[i] > usMaxVal)
		{
			s_MP3Spec_CurVal[i] = usMaxVal;
		}
		
		if(s_MP3Spec_TopVal[i] > usMaxVal)
		{
			s_MP3Spec_TopVal[i] = usMaxVal;
		} 
	}
	
	
	/* 6. 绘制得到的频谱 */
	for(i = 0; i < 31; i++)
	{
		/* 显示频谱 */
		GUI_DrawGradientV(x, 
		                  y + usMaxVal - s_MP3Spec_CurVal[i], 
		                  x + 10, 
		                  y + usMaxVal, 
		                  GUI_YELLOW, 
		                  GUI_GREEN);

		/* 显示顶值 */
		GUI_SetColor(GUI_RED);
		GUI_DrawHLine(y + usMaxVal - s_MP3Spec_TopVal[i] - 1, x, x + 10);
		x += 13;
	}
}
/*********************************************************************
*
*       _cbDialog
*/
//RTA无效区域
static const   GUI_RECT  Rect = { 0, hight_y, 400, 230 }; /* 左上角x，y，右下角x，y*/
static const   GUI_RECT  Rect_string = { 100, 0, 300, 34 };

static void _cbDialog(WM_MESSAGE * pMsg) {
	
	WM_HWIN hItem;
	int     NCode;
	int     Id;
	// USER START (Optionally insert additional variables)
	// USER END

	switch (pMsg->MsgId) {
		// USER START (Optionally insert additional message handling)
		// USER END
	case WM_INIT_DIALOG:
		//设置更新定时器
		Current_Data->hItime1 = WM_CreateTimer(pMsg->hWin, ID_TIMER_SPEC, 20, 0);
		//设置背景
		hItem = pMsg->hWin;
		WINDOW_SetBkColor(hItem, GUI_MAKE_COLOR(0x00000000));

		//切换按钮
		hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_0);
		WM_SetCallback(hItem, _cbButton_left);
		BUTTON_SetFocussable(hItem, 0); //不接受输入焦点

		hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_1);
		WM_SetCallback(hItem, _cbButton_right);
		BUTTON_SetFocussable(hItem, 0); //不接受输入焦点
		break;
	
	/**************************************子窗口发生变化通知消息***********************************************/	
	case WM_NOTIFY_PARENT:
		Id = WM_GetId(pMsg->hWinSrc);  //获得是哪个子窗口发生变化
		NCode = pMsg->Data.v;          //子窗口发生什么变化
	
		//消息处理
		switch(Id)
		{
			//left
			case ID_BUTTON_0:
				switch(NCode)
				{
					//已点击按钮
					case WM_NOTIFICATION_CLICKED:
						break;
					
					//已释放按钮
					case WM_NOTIFICATION_RELEASED:
						Item_change(&Current_Data->RTA_Channel,RTA_IN1,RTA_OUT8,Last_dir);
						RTA_Choose(Current_Data->RTA_Channel);//重新设置RTA通道
						WM_InvalidateRect(pMsg->hWin, &Rect_string); //无效化部分界面
//						WM_InvalidateRect(pMsg->hWin, &Rect); //无效化部分界面
						break;
				}
				break;
				
			//right
			case ID_BUTTON_1:
				switch(NCode)
				{
					//已点击按钮
					case WM_NOTIFICATION_CLICKED:
						break;
					
					//已释放按钮
					case WM_NOTIFICATION_RELEASED:
						Item_change(&Current_Data->RTA_Channel,RTA_IN1,RTA_OUT8,Next_dir);
						RTA_Choose(Current_Data->RTA_Channel);//重新设置RTA通道
						WM_InvalidateRect(pMsg->hWin, &Rect_string); //无效化部分界面	
//						WM_InvalidateRect(pMsg->hWin, &Rect); //无效化部分界面
						break;
				}
				break;
		}
		break;
			
	case WM_TIMER:
		Id = WM_GetTimerId(pMsg->Data.v);
		switch (Id)
		{
			case ID_TIMER_SPEC:
				WM_InvalidateRect(pMsg->hWin, &Rect); //无效化部分界面
				WM_RestartTimer(pMsg->Data.v, Time_delay);  //重新启动定时器
				break;
		}
		break;

		//绘制图画
	case WM_PAINT:

		//第一项
		GUI_SetColor(GUI_RED);
		GUI_FillRoundedRect(0, 0, 400, 30, 4);
		
		//显示字符串
		Show_Value();
		DisWave(0,hight_y,0);  //显示频谱
		break;

	/**********************************自定义信息**********************************/
	case MSG_SLIDER_L:
		GUI_EndDialog(pMsg->hWin, 0); //结束本界面
		hWin_now = Meter_Show(); //显示界面
		break;
	
	case MSG_SLIDER_R:
		GUI_EndDialog(pMsg->hWin, 0); //结束本界面
		hWin_now = CreateMainface(); //显示界面
		break;
	
	//INPUT左转
	case MSG_KNOB_INPUT_LEFT:
		Item_change(&Current_Data->RTA_Channel,RTA_IN1,RTA_OUT8,Next_dir);
		RTA_Choose(Current_Data->RTA_Channel);//重新设置RTA通道
		WM_InvalidateRect(pMsg->hWin, &Rect_string); //无效化部分界面	
//		WM_InvalidateRect(pMsg->hWin, &Rect); //无效化部分界面
		break;
	
	//INPUT右转
	case MSG_KNOB_INPUT_RIGHT:
		Item_change(&Current_Data->RTA_Channel,RTA_IN1,RTA_OUT8,Last_dir);
		RTA_Choose(Current_Data->RTA_Channel);//重新设置RTA通道
		WM_InvalidateRect(pMsg->hWin, &Rect_string); //无效化部分界面
//		WM_InvalidateRect(pMsg->hWin, &Rect); //无效化部分界面
		break;
	
	//页面切换
	case MSG_KNOB_OUT_LEFT:	
		GUI_EndDialog(pMsg->hWin, 0);   //结束当前界面
		hWin_now = CreateMainface();      //切换下一个界面
		break;
	
	case MSG_KNOB_OUT_RIGHT:
		GUI_EndDialog(pMsg->hWin, 0);   //结束当前界面
		hWin_now = Meter_Show();      //切换下一个界面
		break;
	
	//INPUT
	case MSG_KEY_INPUT:
        GUI_EndDialog(pMsg->hWin, 0); //结束本界面
		hWin_now = Input_First(); //显示INPUT第一个界面
		break;
	
	//OUTPUT
	case MSG_KEY_OUTPUT:
        GUI_EndDialog(pMsg->hWin, 0); //结束本界面
		hWin_now = Output_First(); //显示INPUT第一个界面
		break;
	
	//ESC
	case MSG_KEY_ESC:
		GUI_EndDialog(pMsg->hWin, 0); //关闭当前窗口
		hWin_now = CreateMainface();  //显示主页面
		break;
	
	//触摸测试
	case WM_TOUCH:
		huadong(pMsg);
		break;
	
	default:
		WM_DefaultProc(pMsg);
		break;
	}
}

/*********************************************************************
*
*       Public code
*
**********************************************************************
*/
/*********************************************************************
*
*       CreateWindow
*/
#define slider_direct  50
//滑动检测
static void huadong(WM_MESSAGE* pMsg)
{
	const GUI_PID_STATE* pState = (const GUI_PID_STATE*)pMsg->Data.p; //获得PID输入设备的数据
	int direct;
    if (pMsg->Data.p)    /* Something happened in our area (pressed or released) */
    {
        if (pState->Pressed)  //按下
        {
			if(Current_Data->touch_hua == 0)
			{
				Current_Data->touch_hua = 1;
				Current_Data->touch_x_last 	= pState->x;
				Current_Data->touch_y_last	= pState->y;
			}
		}
		else  //释放
		{
			Current_Data->touch_hua = 0;
			Current_Data->touch_x_current 	= pState->x;
			Current_Data->touch_y_current	= pState->y;
			direct = Current_Data->touch_x_current - Current_Data->touch_x_last;
			if(direct > slider_direct ) //滑动距离超过100个像素点
			{
				WM_SendMessageNoPara(hWin_now, MSG_SLIDER_R);
			}
			else if(direct<-slider_direct)
			{
				WM_SendMessageNoPara(hWin_now, MSG_SLIDER_L);
			}

		}
	}
}

//初始化数据
static void Init_data(RTA_First_Data *L)
{
	L->touch_hua = 0;
	
	
	//根据RTA_Channel选择RTA通道
	RTA_Choose(L->RTA_Channel);
}


WM_HWIN RTA_Show(void) {
	WM_HWIN hWin;
	
	Init_data(RTA_first); //初始化数据
	
	Current_Data = RTA_first;
	hWin = GUI_CreateDialogBox(_aDialogCreate, GUI_COUNTOF(_aDialogCreate), _cbDialog, WM_HBKWIN, 0, 0);
	return hWin;
}

// USER START (Optionally insert additional public code)
// USER END

/*************************** End of file ****************************/
